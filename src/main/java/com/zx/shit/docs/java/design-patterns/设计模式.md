#设计模式
##1.说一下你熟悉的设计模式？
创造型：工厂方法模式（FactoryMethod）、抽象工厂模式（AbstractFactory）、建造者模式（Builder）、原型模式（ProtoType）、单例模式（Singleton）
结构型：适配器模式（Adapter）、桥接模式（Bridge）、组合模式（Composite）、装饰者模式（Decorator）、门面模式（Facade）、享元模式（Flyweight）
    、代理模式（Proxy）
行为型：解释器模式（Interpreter）、模板方法模式（TemplateMethod）、责任链模式（Chain Of Responsibility）、命令模式（Command）
    、迭代器模式（Iterator）、调解者模式（Mediator）、备忘录模式（Memento）、观察者模式（Observer）、状态模式（State）、策略模式（Strategy）
    、访问者模式（Visitor）
通常来说设计模式都是混合使用，不会独立应用。充分穷举法充分理解设计模式的应用场景。
在平时的应用中，不是用设计模式去生搬硬套，在业务中根据具体业务问题需要时借鉴。




##2.简单工厂和抽象工厂有什么区别？
• 简单工厂：用来生产同一等级结构中的任意产品，对于增加新的产品，无能为力。
• 工厂方法：用来生产同一等级结构中的固定产品，支持增加任意产品。
• 抽象工厂：用来生产不同产品族的全部产品，对于增加新的产品，无能为力；支持增加产品族。

##3.单例模式是什么？有什么缺点吗？
单例模式是为了保证创建对象的唯一性而产生的，主要有懒汉式和饿汉式。在多线程中，饿汉式是已经创建好了对象，所以不会出现创建多个对象的问题，
而懒汉式可能出现创建多个对象的问题。不保证对象的唯一性。

##3.1单例模式可以通过什么方式保证对象的唯一性？
通过双重校验锁机制保证对象唯一性，在执行方法前判空，再加锁，锁当前对象。再判空，最后创建对象。
##3.1.1为什么要判空两次，每次判空的目的是什么？
第一次判空是为了提高执行效率，当对象已创建后，就不用进入加锁判空创建对象的逻辑。
第二次判空是为了保证创建多个对象的情况出现，比如当两个线程AB，A第一次进行判空singleton == null 此时线程B获得时间片，由于A还没进入获取锁的逻辑，
B直接判断singleton也是null，执行获取锁的逻辑创建对象（无二次判空）。此时A线程再执行，获取锁创建对象。此时就创建了两个对象， 当有了二次判空，
A此时再获取对象，对象就不为null，就不会创建对象，就保证了对象的唯一性。但是这个还有一个问题。
##3.1.2单例双重校验锁下为什么还要在对象引用前加Volatile关键字呢？
因为JVM有个指令重排操作，比如以下三个指令操作。
指令1：获取singleton内存地址
指令2：初始化singleton对象（赋值之类）
指令3：将这块内存地址指向引用singleton
正常情况是1-2-3这样有序指向，现在JVM指令重排后，比如上个场景中，B对象执行创建创建对象时，顺序是132。刚执行完3时，A线程获取CPU时间片，开始执行。
执行到第二次判空时，获取引用对象此时引用虽然已有了内存地址，但是还未完成赋值。拿到的是一个半成品对象。所以我们要在singleton引用前加上volatile
关键字来防止指令重排。

###4.