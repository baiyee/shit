#设计模式

##0.什么是设计模式？
设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。
使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性、程序的重用性。

##0.1为什么要学习设计模式？
• 看懂源代码：如果你不懂设计模式去看Jdk、Spring、SpringMVC、IO等等等等的源码，你会很迷茫，你会寸步难行
• 看看前辈的代码：你去个公司难道都是新项目让你接手？很有可能是接盘的，前辈的开发难道不用设计模式？
• 编写自己的理想中的好代码：我个人反正是这样的，对于我自己开发的项目我会很认真，我对他比对我女朋友还好，把项目当成自己的儿子一样

##0.2设计模式的分类
![](./pictures/设计模式.png)
• 创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。
• 结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。
• 行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。

##0.3设计模式的六大原则？
![](./pictures/六大原则.jpg)
• 开放封闭原则（Open Close Principle）
    ▪ 原则思想：尽量通过扩展软件实体来解决需求变化，而不是通过修改已有的代码来完成变化
    ▪ 描述：一个软件产品在生命周期内，都会发生变化，既然变化是一个既定的事实，我们就应该在设计的时候尽量适应这些变化，以提高项目的稳定性和灵活性。
    ▪ 优点：单一原则告诉我们，每个类都有自己负责的职责，里氏替换原则不能破坏继承关系的体系。
• 里氏代换原则（Liskov Substitution Principle）
    ▪ 原则思想：使用的基类可以在任何地方使用继承的子类，完美的替换基类。
    ▪ 大概意思是：子类可以扩展父类的功能，但不能改变父类原有的功能。子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法，子类中可以增加自己特有的方法。
    ▪ 优点：增加程序的健壮性，即使增加了子类，原有的子类还可以继续运行，互不影响。
• 依赖倒转原则（Dependence Inversion Principle）
    ▪ 依赖倒置原则的核心思想是面向接口编程.
    ▪ 依赖倒转原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，
    ▪ 这个是开放封闭原则的基础，具体内容是：对接口编程，依赖于抽象而不依赖于具体。
• 接口隔离原则（Interface Segregation Principle）
    ▪ 这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。
    ▪ 例如：支付类的接口和订单类的接口，需要把这俩个类别的接口变成俩个隔离的接口
    ▪ 迪米特法则（最少知道原则）（Demeter Principle）
• 原则思想：一个对象应当对其他对象有尽可能少地了解，简称类间解耦
    ▪ 大概意思就是一个类尽量减少自己对其他对象的依赖，原则是低耦合，高内聚，只有使各个模块之间的耦合尽量的低，才能提高代码的复用率。
    ▪ 优点：低耦合，高内聚。
• 单一职责原则（Principle of single responsibility）
    ▪ 原则思想：一个方法只负责一件事情。
    ▪ 描述：单一职责原则很简单，一个方法 一个类只负责一个职责，各个职责的程序改动，不影响其它程序。 这是常识，几乎所有程序员都会遵循这个原则。
    ▪ 优点：降低类和类的耦合，提高可读性，增加可维护性和可拓展性，降低可变性的风险。

##0.4J2EE中使用了哪些设计模式？
Structural（结构模式）
• Adapter:
    java.util.Arrays#asList()
    javax.swing.JTable(TableModel)
    java.io.InputStreamReader(InputStream)
    java.io.OutputStreamWriter(OutputStream)
    javax.xml.bind.annotation.adapters.XmlAdapter#marshal()
    javax.xml.bind.annotation.adapters.XmlAdapter#unmarshal()
• Bridge:
把抽象和实现解藕，于是接口和实现可在完全独立开来.
    AWT (提供了抽象层映射于实际的操作系统)
    JDBC 

##1.说一下你熟悉的设计模式？
创造型：工厂方法模式（FactoryMethod）、抽象工厂模式（AbstractFactory）、建造者模式（Builder）、原型模式（ProtoType）、单例模式（Singleton）
结构型：适配器模式（Adapter）、桥接模式（Bridge）、组合模式（Composite）、装饰者模式（Decorator）、门面模式（Facade）、享元模式（Flyweight）
    、代理模式（Proxy）
行为型：解释器模式（Interpreter）、模板方法模式（TemplateMethod）、责任链模式（Chain Of Responsibility）、命令模式（Command）
    、迭代器模式（Iterator）、调解者模式（Mediator）、备忘录模式（Memento）、观察者模式（Observer）、状态模式（State）、策略模式（Strategy）
    、访问者模式（Visitor）
通常来说设计模式都是混合使用，不会独立应用。充分穷举法充分理解设计模式的应用场景。
在平时的应用中，不是用设计模式去生搬硬套，在业务中根据具体业务问题需要时借鉴。

##2.简单工厂和抽象工厂有什么区别？
• 简单工厂：用来生产同一等级结构中的任意产品，对于增加新的产品，无能为力。
• 工厂方法：用来生产同一等级结构中的固定产品，支持增加任意产品。
• 抽象工厂：用来生产不同产品族的全部产品，对于增加新的产品，无能为力；支持增加产品族。

##3.单例模式是什么？有什么缺点吗？
单例模式是为了保证创建对象的唯一性而产生的，主要有懒汉式和饿汉式。在多线程中，饿汉式是已经创建好了对象，所以不会出现创建多个对象的问题，
而懒汉式可能出现创建多个对象的问题。不保证对象的唯一性。

##3.1单例模式可以通过什么方式保证对象的唯一性？
通过双重校验锁机制保证对象唯一性，在执行方法前判空，再加锁，锁当前对象。再判空，最后创建对象。
##3.1.1为什么要判空两次，每次判空的目的是什么？
第一次判空是为了提高执行效率，当对象已创建后，就不用进入加锁判空创建对象的逻辑。
第二次判空是为了保证创建多个对象的情况出现，比如当两个线程AB，A第一次进行判空singleton == null 此时线程B获得时间片，由于A还没进入获取锁的逻辑，
B直接判断singleton也是null，执行获取锁的逻辑创建对象（无二次判空）。此时A线程再执行，获取锁创建对象。此时就创建了两个对象， 当有了二次判空，
A此时再获取对象，对象就不为null，就不会创建对象，就保证了对象的唯一性。但是这个还有一个问题。
##3.1.2单例双重校验锁下为什么还要在对象引用前加Volatile关键字呢？
因为JVM有个指令重排操作，比如以下三个指令操作。
指令1：获取singleton内存地址
指令2：初始化singleton对象（赋值之类）
指令3：将这块内存地址指向引用singleton
正常情况是1-2-3这样有序指向，现在JVM指令重排后，比如上个场景中，B对象执行创建创建对象时，顺序是132。刚执行完3时，A线程获取CPU时间片，开始执行。
执行到第二次判空时，获取引用对象此时引用虽然已有了内存地址，但是还未完成赋值。拿到的是一个半成品对象。所以我们要在singleton引用前加上volatile
关键字来防止指令重排。

###4.适配器模式(Adapter)？


###5.桥接模式(Bridge)？


###6.组合模式(Composite)？


###7.装饰者模式(Decorator)？


###8.门面模式(Facade)？


###9.享元模式(Flyweight)？


###10.代理模式(Proxy)？


###10.解释器模式(Interpreter)？

###11.模板方法模式(Template Method)?

###12.责任链模式（Chain Of Responsibility）？

###13.命令模式（Command）？

###14.迭代器模式（Iterator）？


###15.调解者模式（Mediator）？

###16.备忘录模式（Memento）？


###17.观察者模式（Observer）？


###18.、状态模式（State）？

###19.策略模式（Strategy）？


###20.访问者模式（Visitor）？

