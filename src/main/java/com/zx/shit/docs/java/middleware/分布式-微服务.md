
## 分布式与微服务总结

### 1.什么是CAP理论？
CAP理论是分布式领域中非常重要的一个指导理论，C(Consistency)一致性，A(Availability)可用性，P(Partition Tolerance) 分区容错性。
CAP理论指出目前的硬件条件下，一个分布式系统是必须要保证分区容错性，而在这个前提下，分布式系统要么保证CP，要么保证AP，无法同时保证CAP。
分区容错性表示，一个系统虽然是分布式的，但是对外看上去应该是一个整体，不能由于分布是系统内部的某个节点挂掉，或网络出现了故障，
而导致系统对外出现异常。所以，对于分布式系统而言是一定要保证分区容错性。

强一致性表示，一个分布式系统中各个节点之间能及时的同步数据，在数据同步的过程中，是不能对外提供服务的，不然就会造成数据不一致，
所以强一致性和可用性是不能同时满足的。

可用性表示，一个分布式系统对外要保证可用。

### 2.什么是BASE理论？
由于不能同时满足Consistency Availability Partition Tolerance CAP，所以出现了BASE理论：
1.BA：Basically Available，表示基本可用，表示可用运行一定程序的不可用，比如由于系统故障，请求时间边长，
或者由于系统故障导致部分非核心功能不可用，都是允许的。
2.S：Soft state：表示分布式系统可以处于一种中间状态，比如数据正在同步.
3.E：Eventually consistent，表示最终一致性，不要求分布式系统数据实时达到一致，允许在经过一段时间后，再达到一致，
在达到一致的过程中，系统也是可用的。
总结：base理论是由于cap中只能保证ap 或者cp时，base理论是对其的补充，允许保证cp时，部分功能a可用。

### 3.什么是RPC?
RPC，表示远程过程调用，对于Java这种面向对象语言，也可以理解为远程方法调用，RPC调用和HTTP调用是有区别的，
RPC表示是一种调用远程方法的方式，可以使用HTTP协议、或直接基于TCP协议来实现RPC，在Java中，我们可以通过直接使用某个服务接口的
代理对象来执行方法，而底层则通过构造HTTP请求来调用远程方法，也可以说RPC协议是在HTTP协议上一层的。

### 4.数据一致性模型有哪些？
• 强一致性
当数据更新完成之后，任何多个后续进程的访问都会返回最新的更新过的值，这种是对用户最友好，用户上一次写什么，下一次就保证能读到什么。
根据CAP理论，这种实现需要牺牲可用性。

• 弱一致性
系统在数据写入成功之后，不承诺立即可以读到最新写入的值，也不会具体的承诺多久之后，可以读到。
用户读到刚刚操作的结果需要等待一段时间，这段时间内系统正在更新。我们称这段时间为"不一致窗口"。

• 最终一致性
最终一致性是弱一致性的特例，在一段时间内，保证数据能达到一致，也就是说告知用户一个特定的时间内，用户此次修改能够可见。
不需要实时可见，这样就能保证可用性的前提下，也保证一致性。
到达最终一致性的时间，就是不一致窗口时间，在没有故障发生的前提下，不一致窗口的时间主要受通信延迟，系统负载和复制副本的个数影响。
最终一致性模型根据其提供的不同保证可以划分为更多的模型，包括因果一致性和会话一致性。

### 3.什么是ZAB协议？
ZAB协议是Zookeeper用来实现一致性的原子广播协议，该协议描述了Zookeeper是如何实现一致性的，分为三个阶段：
1.领导者选举阶段：从Zookeeper集群中选出一个节点作为Leader，所有写请求都会由Leader节点来处理。
2.数据同步节点：集群中所有节点中的数据要和Leader节点保存一致，如果不一致则要进行同步。
3.请求广播阶段：当Leader节点接收到写请求时，会利用两阶段提价来广播该写请求，使得写请求像事务一样在其他节点上执行，达到节点上的数据实时一致。
Zookeeper只是尽量达到强一致性，实际上仍然是最终一致性。

### 4.简述paxos算法？(未完全搞懂.....)
Paxos算法是解决一个分布式系统如何就某个值（决议）达成一致。一个经典的场景是，在一个分布式数据库系统中，如果每个节点的初始状态一致，
每个节点执行相同的操作序列，那么他们最后能够得到一致的状态。
为了保证每个节点执行相同的操作序列，需要在每条指令上执行一个"一致性算法"保证每个阶段看到的指令一致。
在Paxos算法中，有三种角色：Proposer（提议者），Acceptor（接收者），Learners（记录员）
Proposer提议者：只要proposer发的提案Propose被半数以上的Acceptor接受，Proposer就认为该提案的value被选定了。
Acceptor接收者：只要Acceptor接收了某个提案，Acceptor就认为该提案的value被选定了Learner记录员：Acceptor就告诉Learner哪个value被选定，
Learner就认为哪个value被选定。
Paxos算法分为两个阶段，阶段一（prepare）：
• Proposer收到client请求或发现本地有未提交的值，选择一个提案编号N，然后向半数以上的Acceptor发送编号为N的prepare请求。
• Acceptor收到一个编号为N的Prepare请求，如果该轮paxos本节点已有提交的value就来，对比记录的编号和N，大于N则拒绝回应，否则返回该记录value及编号。
没有已提价记录，判断本地是否有编号N1，N1>N、则拒绝响应，否则将N1改为N（如果没有N1,则记录N），并响应prepare

阶段二  巴拉巴拉巴拉........

### 5.简述raft算法？


### 6.消息队列的选型？
• Kafka：
    ▪ 优点： 吞吐量大，性能好，集群高可用。
    ▪ 缺点：会丢数据，功能比较单一。
    ▪ 使用场景：日志分析、大数据采集。
• RabbitMQ：
    ▪ 优点：消息可靠性高，功能全面。
    ▪ 缺点：吞吐量低，消息积累会严重影响性能。erlang语言不好定制。
    ▪ 使用场景：小规模场景。
• RocketMQ：
    ▪ 优点：高吞吐、高性能、高可用，功能全面。
    ▪ 缺点：开源版功能不如云上商业版。官方文档和周边生态不够成熟，客户端只支持java。
    ▪ 使用场景：几乎是全场景。
   