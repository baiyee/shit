
## Redis总结


###0.为什举要使用缓存？
性能：不使用缓存时，当SQL耗时特别久，且固定不便时，系统性能会很差。使用缓存后，直接从缓存中读取，减少对数据库操作，性能提升，迅速响应。
并发：大并发情况下，所有请求直接访问数据库，会造成数据库出现连接异常。使用redis作为缓冲操作。

### 1.什么是Redis？
Redis是一个开源的、C语言编写、遵守BSD协议，高性能分布式（key/value）存储内存数据库，支持持久化。
Redis可用作数据库，缓存，锁，中间件。
Redis支持8种数据类型，常用5种，Strings，Hash，List，Set，zSet。不常用的Bitmaps、Hyperloglogs、地理空间Geospatial。
Redis还支持事务、持久化、Lua脚本、多种集群方案。

###1.1redis有哪些优势？
• 数据持久化，redis能将数据持久化到磁盘中，重启后再次加载数据，保证数据的不丢失。
• 支持key/value类型的数据，还支持，set，zset，hash，list数据
• 支持数据备份，master/slave模式的数据备份


###2.redis是单线程还是多线程的？
redis是单进程单线程的，基于内存操作，不会产生多线程下带来的性能消耗。
CPU不是Redis的瓶颈，Redis的瓶颈是机器内存大小或网络带宽。
这里所说的单线程是指网络请求redis时只用一个线程处理。
redis采用单线程-io多路复用模型进行处理数据的，非阻塞io，这种机制避免了加锁。

###2.1为什么说redis是单线程的？
Redis基于Reactor模型开发了文件事件处理模型，文件事件处理模型是单线程的，所以说Redis是单线程模型

###2.3那么redis是单线程的，怎么监听客户端大量的连接呢？
Redis是通过I/O多路模型来监听客户端大量连接的，或者监听多个（socket），它会将感兴趣的事件及类型（读、写）注册到内存中并监听每个事件是否发生。

###2.4 redis I/O多路模型的好处？
不需要创建多余线程来监听客户端大量连接， 降低资源消耗（和NIO中的Selector组件很像）

###2.1单线程下无法发挥多核cpu性能，怎么解决？
可以在单机上启动多个redis实例来解决。


###3.I/O多路复用模型是什么？
I/O多路复用模式是利用select、poll、epoll可以同时监察多个流的I/O事件的能力。

###4.如何保证Redis和MySQL的数据一致性？
• 前言：客户端对数据中的数据主要有两类操作，读(select)或写(add,update,delete)。针对放入redis缓存中的热点数据，
        命中缓存（cache hit），客户端读取的数据刚好在缓存中且直接返回数据
        缓存未命中（cache miss），缓存未查到数据，查数据库。
        读操作并不会导致缓存与数据库不一致。
• 对于写操作(DML)，缓存与数据库中内容都需要被修改，两者必定存在一个先后顺序，可能会导致缓存与数据库中数据不一致。
这时候需要考虑1.是先更新缓存还是先更新数据库呢？2.更新策略，当缓存数据变化是先update，还是直接delete。
![](./pictures/Redis与MySQL数据一致性.webp)
• 缓存不一致场景：
    读redis、和MySQL不会出现缓存不一致问题，但是会出现缓存失效，缓存未命中问题。
    双写场景， 1.先update mysql 再 update redis  2个线程同时操作，会出现 redis 与mysql 的数据不一致(脏数据)。与线程执行顺序有关。
            2.解决方案，改为 先update mysql  再 del redis  就不会出现这个问题。
    单写单读场景，1.线程A，线程B，A写操作（先写mysql，再删redis），B读操作（先读redis，没有数据再读数据库）没啥问题
    单写单读先删缓存再更新数据库，就会出现缓存与数据库不一致。
             解决方案：可以采用延迟双删策略。删缓存，更新库后，再sleep 1秒，再删缓存，就杜绝了缓存是旧数据情况。
    删除缓存失败，会导致脏数据。
             解决方案：删除缓存重试，先修改库，再删缓存，失败后，将key 放入消息队列，消费端获取key，重试删除缓存操作。
             
    总结：1.延迟双删+失败重试（先删缓存，再删库，再sleep，再删缓存，删除失败后再将key放入消息队列，消费端获取是否存在判断是否删除成功，不成功继续删。）
    
### 5.缓存雪崩？
缓存雪崩：原有的缓存失效，新缓存未到期限（我们给缓存设置了相同的过期时间，缓存在同一时间出现大面积过期失效），失效期间，原本查询缓存的请求，全都直接
查询数据库。对数据库CPU和内存造成了巨大压力，严重会导致数据库宕机，系统崩溃。
简言之，缓存时间设置相同，同一时刻缓存失效，大并发请求数据库，系统崩溃。

### 5.1如何预防缓存雪崩？
• 给过期Key加一个随机值时间，使得每个key的过期时间分布开来，不会集中在同一时刻失效。
• 采用redis 令牌桶或滑动窗口算法限制流量，通过加一个标识flag，判断key是否过期，过期则删除缓存。
• 采用分布式锁。

###6.缓存穿透？
缓存穿透：用户查询数据，在数据库中没有，在缓存中也不会有。导致用户查询了缓存和数据库都返回null。进行了两次无用功操作。并发高时，直接绕开缓存对数据库查询
这就是缓存命中率的问题。

###6.1如何预防缓存穿透？
• 采用布隆过滤器，通过redis的bitmap位图操作，将可能查询到的数据哈希到bitmap，一定不存在的数据会被bitmap拦截掉，避免了对数据库的查询压力。
• 如果一个查询的数据为null，将这个null值也存入redis中，并且设置一个短的过期时间，一般不超过5分钟。这种方法简单粗暴。

###7.Redis分布式锁是如何实现的？
1.首先使用setnx命令来保证：如果key不存在才能获取到锁，如果key存在，则获取不到锁。
2.然后还要利用lua脚本来保证多放个redis操作的原子性。
3.同时还要考虑到锁过期，所以需要一个额外的看门狗定时任务来监听锁是否需要续约。
4.同时还要考虑redis节点挂掉后的情况，所以需要采用红锁的方式来同时向N/2+1个节点申请锁，都申请到了才证明获取锁成功了，这样就算其中某个redis节点挂掉了，锁也不能被其他客户端获取到。


###7.1Redis Redisson的实现？
由于reids + lus脚本的实现有个缺陷是，当redis 过期时间小于程序执行时间时，锁自动释放了又被其他线程获取了，在电商项目中容易发生超卖的问题。
![](./pictures/Redisson机制实现.jpg)
Redisson锁机制如上图，线程去获取锁，获取成功则执行Lua脚本，保存数据到redis数据库。
如果获取失败：一致通过while循环尝试获取锁（可自定义等待时间，超时后返回失败），获取成功后，执行lua脚本，保存数据到数据库。
Redisson提供的分布式锁是支持自动续期的，也就是说，如果线程仍旧没有执行完，那么redisson会自动给redis中的目标key延长超时时间，这在Redisson中称之为Watch Dog机制。
同时redisson还有公平锁、读写锁的实现。
````java
public class t1{
    private void redissonDoc() throws InterruptedException {    //1. 普通的可重入锁
        RLock lock = redissonClient.getLock("generalLock");    // 拿锁失败时会不停的重试
        // 具有Watch Dog 自动延期机制 默认续30s 每隔30/3=10 秒续到30s
        lock.lock();    // 尝试拿锁10s后停止重试,返回false
        // 具有Watch Dog 自动延期机制 默认续30s
        boolean res1 = lock.tryLock(10, TimeUnit.SECONDS);    // 拿锁失败时会不停的重试
        // 没有Watch Dog ，10s后自动释放
        lock.lock(10, TimeUnit.SECONDS);    // 尝试拿锁100s后停止重试,返回false
        // 没有Watch Dog ，10s后自动释放
        boolean res2 = lock.tryLock(100, 10, TimeUnit.SECONDS);    //2. 公平锁 保证 Redisson 客户端线程将以其请求的顺序获得锁
        RLock fairLock = redissonClient.getFairLock("fairLock");    //3. 读写锁 没错与JDK中ReentrantLock的读写锁效果一样
        RReadWriteLock readWriteLock = redissonClient.getReadWriteLock("readWriteLock");
        readWriteLock.readLock().lock();
        readWriteLock.writeLock().lock();
    }
}
````

### 8.Redis主从复制的核心原理？
Redis主从复制是提高Redis可靠性的有效措施，主从复制的流程如下：
1.集群启动时，主从库会先建立连接，为全量复制做准备。
2.主库将所有数据同步给从库，从库收到数据后，在本地完成数据加载，这个过程依赖于内存快照RDB。
3.在主库将数据同步给从库的过程中，主库不会阻塞，仍然可以正常接收请求。但是这些新请求的写操作并没有记录到刚刚生成的RDB文件中，为了保证主从库的数据一致性，
主库会在内存中用专门的replication buffer，记录RDB文件生成收到的所有写操作。
4.最后，主库会把内存中新接收的写命令，再发送给从库。具体操作是，当主库完成RDB文件发送后，就会把replocation buffer中修改操作发送给从库，从库再执行这些操作。
这样一来，主从库就实现同步了。  
5.后续主库和从库都可以处理客户端读操作，写操作只能交给主库处理，主库接收到写操作后，还会将写操作发送给从库，实现增量同步。