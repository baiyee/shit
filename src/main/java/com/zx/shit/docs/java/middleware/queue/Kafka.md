
# Kafka总结

## 1.什么是Kafka？
Kafka是一种高吞吐量、分布式、基于发布/订阅的消息系统(Message Queue)，最初由 LinkedIn 公司开发，使用
Scala 语言编写，目前是 Apache 的开源项目。

### 1.2.Kafka与MQ的区别？
1.天生分布式
2.存储数据（磁盘 持久化） 有保留策略 默认7天 大小1G 需求修改配置
3.流式处理（聚合、统计）
4.多生产者、多消费者
5.天生持久化
 
### 1.3 为什么选择kafka ？
1.多生产者 多消费者
2.天生持久化到磁盘
3.高伸缩性(高吞吐) Kafka中有partition 分区

## 2.kafka的消费模式？
• 点对点模式（消费者主动拉取，消息收到后通知队列移除持久化消息）
  生产者 -> 队列 -> 消费者   一个消息只能被一个消费者消费
  
• 发布订阅模式（一对多，消费者消费消息后不会被移除）
   生产者 -> 队列 -> 多个消费者  一个消息可以被多个消费者共同消费

## 3.kafka 的三种发送方式？
1.发送并忘记
2.同步发送
3.异步发送 

## 4. kafka是如何保证消息顺序的？
1.kafka必须只能有一个分区， partition0，如果有多个分区，分区保障消息顺序是比较困难。
  消息通过先后顺序发送就可以保证顺序
  
## 4.1 kafka中，消息A B顺序发送，由于重试机制，现在A重试时，B先发送。消费者收到的消息顺序就变成了消息B在先消息A在后？如何解决？
• 方案1 采取不重试的方式
  缺点：会导致新问题，消息丢失。
• 方案2 通过配置max.in.flight.request.connection 设置为1，这样生产者在重试的过程中，不允许有其他消息发送到broker。既保证了消息顺序，也保证了消息不会丢失。
  缺点：影响吞吐量，除非是对消息顺序有严格要求的场景才会使用。
  
## 5.kafka中的消费策略？
1.Range 采取权重轮询的方式，根据消费者群组中不同消费者消费能力来进行分发消息的。 出现1多2少的情况。
2.RoundRobin 采取普通轮询的方式， 根据消费组群中，你一个，我一个的方式来发送消息。

6.kafka的ack机制？
request.required.acks 有三个值 0 1 -1
0：生产者不会等待broker的ack，这个延迟最低但是存储的保证最弱，server挂掉就会丢数据。
1：服务端会等待broker 返回ack值leader replica 确认接收到消息后发送ack但是如果leader挂掉，不保证复制完成新leader会导致数据丢失
-1：服务端的follow replica 收到数据后 leader才会再次发送ack，这样数据不会丢失。  
all：生产者发送消息到broker机器后，需要等待 leader 和副本的数据复制后，再发送一个ack消息告知生产者收到了。这样就完全不会保证数据丢失。

7.kafka零拷贝？
生产者->kafka->消费者 ,当消息被发送至kafka时，会进行磁盘持久化，消息会被映射到页面缓存。内存越大，页面缓存越多。当消费者从页面缓存中速度就非常快，
在感官上就相当于生产者直接发送到页面缓存，消费者从页面缓存中取消息。这也就是zero copy。