
# Kafka总结

## 1.什么是Kafka？
Kafka是一种高吞吐量、分布式、基于发布/订阅的消息系统(Message Queue)，最初由 LinkedIn 公司开发，使用
Scala 语言编写，目前是 Apache 的开源项目。

### 1.2.Kafka与MQ的区别？
1.天生分布式
2.存储数据（磁盘 持久化） 有保留策略 默认7天 大小1G 需求修改配置
3.流式处理（聚合、统计）
4.多生产者、多消费者
5.天生持久化
 
### 1.3 为什么选择kafka ？
1.多生产者 多消费者
2.天生持久化到磁盘
3.高伸缩性(高吞吐) Kafka中有partition 分区

## 2.kafka的消费模式？
• 点对点模式（消费者主动拉取，消息收到后通知队列移除持久化消息）
  生产者 -> 队列 -> 消费者   一个消息只能被一个消费者消费
  
• 发布订阅模式（一对多，消费者消费消息后不会被移除）
   生产者 -> 队列 -> 多个消费者  一个消息可以被多个消费者共同消费

## 3.kafka 的三种发送方式？
1.发送并忘记
2.同步发送
3.异步发送 

## 4. kafka是如何保证消息顺序的？
1.kafka必须只能有一个分区， partition0，如果有多个分区，分区保障消息顺序是比较困难。
  消息通过先后顺序发送就可以保证顺序
  
## 4.1 kafka中，消息A B顺序发送，由于重试机制，现在A重试时，B先发送。消费者收到的消息顺序就变成了消息B在先消息A在后？如何解决？
• 方案1 采取不重试的方式
  缺点：会导致新问题，消息丢失。
• 方案2 通过配置max.in.flight.request.connection 设置为1，这样生产者在重试的过程中，不允许有其他消息发送到broker。既保证了消息顺序，也保证了消息不会丢失。
  缺点：影响吞吐量，除非是对消息顺序有严格要求的场景才会使用。
  
## 5.kafka中的消费策略？
1.Range 采取权重轮询的方式，根据消费者群组中不同消费者消费能力来进行分发消息的。 出现1多2少的情况。
2.RoundRobin 采取普通轮询的方式， 根据消费组群中，你一个，我一个的方式来发送消息。

## 6.kafka的ack机制？
request.required.acks 有三个值 0 1 -1
0：生产者不会等待broker的ack，这个延迟最低但是存储的保证最弱，server挂掉就会丢数据。
1：服务端会等待broker 返回ack值leader replica 确认接收到消息后发送ack但是如果leader挂掉，不保证复制完成新leader会导致数据丢失
-1：服务端的follow replica 收到数据后 leader才会再次发送ack，这样数据不会丢失。  
all：生产者发送消息到broker机器后，需要等待 leader 和副本的数据复制后，再发送一个ack消息告知生产者收到了。这样就完全不会保证数据丢失。

## 7.kafka零拷贝？
生产者->kafka->消费者 ,当消息被发送至kafka时，会进行磁盘持久化，消息会被映射到页面缓存。内存越大，页面缓存越多。当消费者从页面缓存中速度就非常快，
在感官上就相当于生产者直接发送到页面缓存，消费者从页面缓存中取消息。这也就是zero copy。

## 8.kafka高可用的原因？
1.磁盘顺序读取，保证了消息堆积。
    • 顺序读写，磁盘会预读，预读即在读的起始地址连续读取多个页面，主要时间花费在了传输时间，而这个时间两种读写可以认为是一样的。(通过预读读取多个页面缓存，没有寻址时间。)
    • 随机读写，因为数据没有在一起，将预读浪费掉了。需要多次寻道和旋转延迟，而这个时间可能是传输时间的许多倍。（随机读写会导致磁盘有寻道和旋转延迟，这个时间是顺序读写的很多倍。）
2.零拷贝：避免CPU将数据从一块存储拷贝到另一块存储的技术
    • 传统的数据复制：
        ▪ 读取磁盘文件数据到内核缓冲区
        ▪ 将内核缓冲区的数据copy到用户缓冲区
        ▪ 将用户缓冲区的数据copy到socket的发送缓冲区
        ▪ 将socket发送缓冲区中的数据发送到网卡、进行传输
    • 零拷贝：
        磁盘文件->内核空间读取缓冲区->网卡接口->消费者进程
3.分区分段+索引
    kafka的message实际上是分布式存储在一个一个小的segment中，每次文件操作也是直接操作的segment。为了进一步的查询优化，
    kafka默认为分段后的数据文件建立了索引文件，就是文件系统上的index文件。这种文件分区分段+索引设计，不仅提升了数据读取的效率，
    同时也提高了操作数据的并行度
4.批量压缩：多条消息一起压缩，降低带宽（kafka批处理，压缩数据，降低带宽消耗）
5.批量读写
6.直接操作page cache，而不是JVM，避免GC耗时及对象创建耗时，且读写速度更高，进程重启，缓存不会丢失。

##9.kafka的pull和push分别有什么优缺点？
1.pull表示消费者主动拉取，可以批量拉取，也可以单条拉取，所以pull可以由消费者自己控制，根据自己的消息处理能力来进行控制，
但是消费者不能及时知道是否有消息，可能会拉倒的消息为空。（就好比生活中，我们去吃饭，自己去盛饭，去盛饭时，我们并不知道是否还有没有饭。）
2.push表示Broker主动给消费者推送消息，所以肯定是有消息时才会推送，但是消费者不能按照自己的能力来消费消息，推过来多少消息，消费者就得消费多少消息，
所以可能造成网络阻塞，消费者压力大等问题（类比生活中，吃饭时，有人端着一碗饭过来给你，并不知道你能不能吃这么多，反正你要吃完。）